// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteNote = `-- name: DeleteNote :execrows
DELETE FROM notes.notes
WHERE note_id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, db DBTX, noteID uuid.UUID) (int64, error) {
	result, err := db.Exec(ctx, deleteNote, noteID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTag = `-- name: DeleteTag :execrows
DELETE FROM notes.tags
WHERE tag_id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, db DBTX, tagID uuid.UUID) (int64, error) {
	result, err := db.Exec(ctx, deleteTag, tagID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM notes.users
WHERE
  user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, db DBTX, userID uuid.UUID) (int64, error) {
	result, err := db.Exec(ctx, deleteUser, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getNote = `-- name: GetNote :one
SELECT
  note_id,
  created_at,
  created_by,
  updated_at,
  updated_by,
  title,
  body
FROM notes.notes
WHERE note_id = $1
`

type GetNoteRow struct {
	NoteID    uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy uuid.NullUUID
	UpdatedAt pgtype.Timestamptz
	UpdatedBy uuid.NullUUID
	Title     string
	Body      string
}

func (q *Queries) GetNote(ctx context.Context, db DBTX, noteID uuid.UUID) (GetNoteRow, error) {
	row := db.QueryRow(ctx, getNote, noteID)
	var i GetNoteRow
	err := row.Scan(
		&i.NoteID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Title,
		&i.Body,
	)
	return i, err
}

const getNoteAccess = `-- name: GetNoteAccess :many
SELECT
  user_note_access.user_id,
  access
FROM notes.user_note_access
JOIN notes.users ON
  user_note_access.user_id = users.user_id
WHERE note_id = $1
`

type GetNoteAccessRow struct {
	UserID uuid.UUID
	Access NotesAccessLevel
}

func (q *Queries) GetNoteAccess(ctx context.Context, db DBTX, noteID uuid.UUID) ([]GetNoteAccessRow, error) {
	rows, err := db.Query(ctx, getNoteAccess, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNoteAccessRow
	for rows.Next() {
		var i GetNoteAccessRow
		if err := rows.Scan(&i.UserID, &i.Access); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoteTags = `-- name: GetNoteTags :many
SELECT
  tags.tag_id,
  name
FROM notes.note_tags
JOIN notes.tags ON
  note_tags.tag_id = tags.tag_id
JOIN notes.user_tag_access ON
  user_tag_access.tag_id = tags.tag_id
  AND user_id = $1
  -- NOTE: any access
WHERE note_id = $2
`

type GetNoteTagsParams struct {
	UserID uuid.UUID
	NoteID uuid.UUID
}

func (q *Queries) GetNoteTags(ctx context.Context, db DBTX, arg GetNoteTagsParams) ([]NotesTag, error) {
	rows, err := db.Query(ctx, getNoteTags, arg.UserID, arg.NoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesTag
	for rows.Next() {
		var i NotesTag
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT
  tag_id,
  name
FROM notes.tags
WHERE tag_id = $1
`

func (q *Queries) GetTag(ctx context.Context, db DBTX, tagID uuid.UUID) (NotesTag, error) {
	row := db.QueryRow(ctx, getTag, tagID)
	var i NotesTag
	err := row.Scan(&i.TagID, &i.Name)
	return i, err
}

const getTagAccess = `-- name: GetTagAccess :many
SELECT
  user_id,
  access
FROM notes.user_tag_access
WHERE tag_id = $1
`

type GetTagAccessRow struct {
	UserID uuid.UUID
	Access NotesAccessLevel
}

func (q *Queries) GetTagAccess(ctx context.Context, db DBTX, tagID uuid.UUID) ([]GetTagAccessRow, error) {
	rows, err := db.Query(ctx, getTagAccess, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagAccessRow
	for rows.Next() {
		var i GetTagAccessRow
		if err := rows.Scan(&i.UserID, &i.Access); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  user_id,
  name,
  created_at,
  last_sign_in,
  active
FROM notes.users
WHERE
  user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, db DBTX, noteID uuid.UUID) (NotesUser, error) {
	row := db.QueryRow(ctx, getUser, noteID)
	var i NotesUser
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.LastSignIn,
		&i.Active,
	)
	return i, err
}

const getUserNoteAccess = `-- name: GetUserNoteAccess :one
SELECT
  access
FROM notes.user_note_access
WHERE note_id = $1
  AND user_id = $2
`

type GetUserNoteAccessParams struct {
	NoteID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetUserNoteAccess(ctx context.Context, db DBTX, arg GetUserNoteAccessParams) (NotesAccessLevel, error) {
	row := db.QueryRow(ctx, getUserNoteAccess, arg.NoteID, arg.UserID)
	var access NotesAccessLevel
	err := row.Scan(&access)
	return access, err
}

const getUserTagAccess = `-- name: GetUserTagAccess :one
SELECT
  access
FROM notes.user_tag_access
WHERE tag_id = $1
  AND user_id = $2
`

type GetUserTagAccessParams struct {
	TagID  uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetUserTagAccess(ctx context.Context, db DBTX, arg GetUserTagAccessParams) (NotesAccessLevel, error) {
	row := db.QueryRow(ctx, getUserTagAccess, arg.TagID, arg.UserID)
	var access NotesAccessLevel
	err := row.Scan(&access)
	return access, err
}

const listNotes = `-- name: ListNotes :many
SELECT
  notes.note_id,
  title
FROM notes.notes
JOIN notes.user_note_access ON
  user_note_access.note_id = notes.note_id
  AND user_id = $1
  -- NOTE: any access
WHERE $2::uuid IS NULL OR notes.note_id > $2::uuid
ORDER BY notes.note_id ASC
LIMIT $3
`

type ListNotesParams struct {
	UserID     uuid.UUID
	LastNoteID uuid.NullUUID
	PageSize   int64
}

type ListNotesRow struct {
	NoteID uuid.UUID
	Title  string
}

func (q *Queries) ListNotes(ctx context.Context, db DBTX, arg ListNotesParams) ([]ListNotesRow, error) {
	rows, err := db.Query(ctx, listNotes, arg.UserID, arg.LastNoteID, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotesRow
	for rows.Next() {
		var i ListNotesRow
		if err := rows.Scan(&i.NoteID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT
  tags.tag_id,
  name,
  access
FROM notes.tags
JOIN notes.user_tag_access ON 
  tags.tag_id = user_tag_access.tag_id
  AND user_id = $1 -- NOTE: any access
WHERE ($2::uuid IS NULL OR tags.tag_id > $2::uuid)
  AND LOWER(name) LIKE '%' || LOWER($3) || '%'
ORDER BY tags.tag_id ASC
LIMIT $4
`

type ListTagsParams struct {
	UserID       uuid.UUID
	LastTagID    uuid.NullUUID
	SearchString string
	PageSize     int64
}

type ListTagsRow struct {
	TagID  uuid.UUID
	Name   string
	Access NotesAccessLevel
}

func (q *Queries) ListTags(ctx context.Context, db DBTX, arg ListTagsParams) ([]ListTagsRow, error) {
	rows, err := db.Query(ctx, listTags,
		arg.UserID,
		arg.LastTagID,
		arg.SearchString,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsRow
	for rows.Next() {
		var i ListTagsRow
		if err := rows.Scan(&i.TagID, &i.Name, &i.Access); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveNote = `-- name: SaveNote :exec
INSERT INTO notes.notes (
  note_id,
  created_at,
  created_by,
  updated_at,
  updated_by,
  title,
  body
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
) ON CONFLICT (note_id) DO UPDATE
  SET updated_at = excluded.updated_at,
      updated_by = excluded.updated_by,
      title      = excluded.title,
      body       = excluded.body
`

type SaveNoteParams struct {
	NoteID    uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy uuid.NullUUID
	UpdatedAt pgtype.Timestamptz
	UpdatedBy uuid.NullUUID
	Title     string
	Body      string
}

func (q *Queries) SaveNote(ctx context.Context, db DBTX, arg SaveNoteParams) error {
	_, err := db.Exec(ctx, saveNote,
		arg.NoteID,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Title,
		arg.Body,
	)
	return err
}

const saveTag = `-- name: SaveTag :exec
INSERT INTO notes.tags (
  tag_id,
  name
) VALUES (
  $1,
  $2
) ON CONFLICT (tag_id) DO UPDATE
  SET name = excluded.name
`

type SaveTagParams struct {
	TagID uuid.UUID
	Name  string
}

func (q *Queries) SaveTag(ctx context.Context, db DBTX, arg SaveTagParams) error {
	_, err := db.Exec(ctx, saveTag, arg.TagID, arg.Name)
	return err
}

const saveUser = `-- name: SaveUser :exec
INSERT INTO notes.users (
  user_id,
  name,
  created_at,
  last_sign_in,
  active
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) ON CONFLICT (user_id) DO UPDATE
  SET name         = excluded.name,
      last_sign_in = excluded.last_sign_in,
      active       = excluded.active
RETURNING user_id, name, created_at, last_sign_in, active
`

type SaveUserParams struct {
	UserID     uuid.UUID
	Name       string
	CreatedAt  pgtype.Timestamptz
	LastSignIn pgtype.Timestamptz
	Active     bool
}

func (q *Queries) SaveUser(ctx context.Context, db DBTX, arg SaveUserParams) error {
	_, err := db.Exec(ctx, saveUser,
		arg.UserID,
		arg.Name,
		arg.CreatedAt,
		arg.LastSignIn,
		arg.Active,
	)
	return err
}

const searchNotesWithTag = `-- name: SearchNotesWithTag :many
SELECT
  notes.note_id,
  title
FROM notes.notes
JOIN notes.user_note_access ON
  user_note_access.note_id = notes.note_id
  AND user_id = $1
  -- NOTE: any access
JOIN notes.note_tags ON
  note_tags.note_id = notes.note_id
WHERE note_tags.tag_id = $2
  AND ($3::uuid IS NULL OR notes.note_id > $3::uuid)
ORDER BY notes.note_id ASC
LIMIT $4
`

type SearchNotesWithTagParams struct {
	UserID     uuid.UUID
	TagID      uuid.UUID
	LastNoteID uuid.NullUUID
	PageSize   int64
}

type SearchNotesWithTagRow struct {
	NoteID uuid.UUID
	Title  string
}

func (q *Queries) SearchNotesWithTag(ctx context.Context, db DBTX, arg SearchNotesWithTagParams) ([]SearchNotesWithTagRow, error) {
	rows, err := db.Query(ctx, searchNotesWithTag,
		arg.UserID,
		arg.TagID,
		arg.LastNoteID,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNotesWithTagRow
	for rows.Next() {
		var i SearchNotesWithTagRow
		if err := rows.Scan(&i.NoteID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNotesWithText = `-- name: SearchNotesWithText :many
SELECT
  notes.note_id,
  title,
  rank::float4,
  ts_headline(title || '\n' || body, query, 'StartSel=<<, StopSel=>>') AS match
FROM notes.notes
CROSS JOIN LATERAL websearch_to_tsquery($1) AS query
CROSS JOIN LATERAL ts_rank_cd(search_index, query) AS rank
JOIN notes.user_note_access ON
  user_note_access.note_id = notes.note_id
  AND user_id = $2
  -- NOTE: any access
WHERE query @@ search_index
  AND $3::float4 IS NULL OR rank::float4 < $3::float4
ORDER BY rank::float4 DESC
LIMIT $4
`

type SearchNotesWithTextParams struct {
	TextSearch string
	UserID     uuid.UUID
	LastRank   pgtype.Float4
	PageSize   int64
}

type SearchNotesWithTextRow struct {
	NoteID uuid.UUID
	Title  string
	Rank   float32
	Match  pgtype.Text
}

func (q *Queries) SearchNotesWithText(ctx context.Context, db DBTX, arg SearchNotesWithTextParams) ([]SearchNotesWithTextRow, error) {
	rows, err := db.Query(ctx, searchNotesWithText,
		arg.TextSearch,
		arg.UserID,
		arg.LastRank,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNotesWithTextRow
	for rows.Next() {
		var i SearchNotesWithTextRow
		if err := rows.Scan(
			&i.NoteID,
			&i.Title,
			&i.Rank,
			&i.Match,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNotesWithTextAndTag = `-- name: SearchNotesWithTextAndTag :many
SELECT
  notes.note_id,
  title,
  rank::float4 AS rank,
  ts_headline(title || '\n' || body, query, 'StartSel=<<, StopSel=>>') AS match
FROM notes.notes
CROSS JOIN LATERAL websearch_to_tsquery($1) AS query
CROSS JOIN LATERAL ts_rank_cd(search_index, query) AS rank
JOIN notes.user_note_access ON
  user_note_access.note_id = notes.note_id
  AND user_id = $2
  -- NOTE: any access
JOIN notes.note_tags ON
  note_tags.note_id = notes.note_id
WHERE tag_id = $3
  AND query @@ search_index
  AND ($4::float4 IS NULL OR rank::float4 < $4::float4)
ORDER BY rank::float4 DESC
LIMIT $5
`

type SearchNotesWithTextAndTagParams struct {
	TextSearch string
	UserID     uuid.UUID
	TagID      uuid.UUID
	LastRank   pgtype.Float4
	PageSize   int64
}

type SearchNotesWithTextAndTagRow struct {
	NoteID uuid.UUID
	Title  string
	Rank   float32
	Match  pgtype.Text
}

func (q *Queries) SearchNotesWithTextAndTag(ctx context.Context, db DBTX, arg SearchNotesWithTextAndTagParams) ([]SearchNotesWithTextAndTagRow, error) {
	rows, err := db.Query(ctx, searchNotesWithTextAndTag,
		arg.TextSearch,
		arg.UserID,
		arg.TagID,
		arg.LastRank,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNotesWithTextAndTagRow
	for rows.Next() {
		var i SearchNotesWithTextAndTagRow
		if err := rows.Scan(
			&i.NoteID,
			&i.Title,
			&i.Rank,
			&i.Match,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setNoteAccess = `-- name: SetNoteAccess :exec
MERGE INTO notes.user_note_access
USING (SELECT $1::uuid AS set_user_id,
              $2::notes.access_level AS set_access) ON
  note_id = $3::uuid
  AND user_id = set_user_id
WHEN MATCHED AND set_access IS NULL THEN
  DELETE
WHEN MATCHED AND set_access IS NOT NULL THEN
  UPDATE SET access = set_access
WHEN NOT MATCHED THEN
  INSERT (note_id, user_id, access)
  VALUES ($3::uuid, set_user_id, set_access)
`

type SetNoteAccessParams struct {
	Column1 uuid.NullUUID
	Column2 NullNotesAccessLevel
	Column3 uuid.NullUUID
}

func (q *Queries) SetNoteAccess(ctx context.Context, db DBTX, arg SetNoteAccessParams) error {
	_, err := db.Exec(ctx, setNoteAccess, arg.Column1, arg.Column2, arg.Column3)
	return err
}

const setNoteTags = `-- name: SetNoteTags :exec
MERGE INTO notes.note_tags
USING (SELECT $2::uuid AS set_tag_id) ON
  note_id = $1::uuid
WHEN MATCHED AND set_tag_id IS NULL THEN
  DELETE
WHEN MATCHED AND set_tag_id IS NOT NULL THEN
  UPDATE SET tag_id = set_tag_id
WHEN NOT MATCHED THEN
  INSERT (note_id, tag_id)
  VALUES ($1::uuid, set_tag_id)
`

type SetNoteTagsParams struct {
	Column1 uuid.NullUUID
	Column2 uuid.NullUUID
}

func (q *Queries) SetNoteTags(ctx context.Context, db DBTX, arg SetNoteTagsParams) error {
	_, err := db.Exec(ctx, setNoteTags, arg.Column1, arg.Column2)
	return err
}

const setTagAccess = `-- name: SetTagAccess :exec
MERGE INTO notes.user_tag_access
USING (SELECT $1::uuid AS set_user_id,
              $2::notes.access_level AS set_access) ON
  tag_id = $3::uuid
  AND user_id = set_user_id
WHEN MATCHED AND set_access IS NULL THEN
  DELETE
WHEN MATCHED AND set_access IS NOT NULL THEN
  UPDATE SET access = set_access
WHEN NOT MATCHED THEN
  INSERT (tag_id, user_id, access)
  VALUES ($3::uuid, set_user_id, set_access)
`

type SetTagAccessParams struct {
	Column1 uuid.NullUUID
	Column2 NullNotesAccessLevel
	Column3 uuid.NullUUID
}

func (q *Queries) SetTagAccess(ctx context.Context, db DBTX, arg SetTagAccessParams) error {
	_, err := db.Exec(ctx, setTagAccess, arg.Column1, arg.Column2, arg.Column3)
	return err
}
