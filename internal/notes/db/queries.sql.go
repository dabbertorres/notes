// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteNote = `-- name: DeleteNote :exec
DELETE FROM notes.notes 
WHERE 
  note_id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, db DBTX, noteID uuid.UUID) error {
	_, err := db.Exec(ctx, deleteNote, noteID)
	return err
}

const getNote = `-- name: GetNote :one
SELECT
  note_id,
  created_at,
  created_by,
  updated_at,
  updated_by,
  title,
  body
FROM notes.notes
WHERE
  note_id = $1
`

type GetNoteRow struct {
	NoteID    uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy uuid.NullUUID
	UpdatedAt pgtype.Timestamptz
	UpdatedBy uuid.NullUUID
	Title     string
	Body      string
}

func (q *Queries) GetNote(ctx context.Context, db DBTX, noteID uuid.UUID) (GetNoteRow, error) {
	row := db.QueryRow(ctx, getNote, noteID)
	var i GetNoteRow
	err := row.Scan(
		&i.NoteID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Title,
		&i.Body,
	)
	return i, err
}

const getNoteAccess = `-- name: GetNoteAccess :many
SELECT
  user_id,
  access
FROM notes.user_note_access
WHERE
  note_id = $1
`

type GetNoteAccessRow struct {
	UserID uuid.UUID
	Access NotesAccessLevel
}

func (q *Queries) GetNoteAccess(ctx context.Context, db DBTX, noteID uuid.UUID) ([]GetNoteAccessRow, error) {
	rows, err := db.Query(ctx, getNoteAccess, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNoteAccessRow
	for rows.Next() {
		var i GetNoteAccessRow
		if err := rows.Scan(&i.UserID, &i.Access); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoteTags = `-- name: GetNoteTags :many
SELECT
  tags.tag_id,
  user_id,
  name
FROM notes.tags
JOIN notes.note_tags ON
  note_tags.tag_id = tags.tag_id
WHERE
  note_id = $1
`

type GetNoteTagsRow struct {
	TagID  uuid.UUID
	UserID uuid.UUID
	Name   string
}

func (q *Queries) GetNoteTags(ctx context.Context, db DBTX, noteID uuid.UUID) ([]GetNoteTagsRow, error) {
	rows, err := db.Query(ctx, getNoteTags, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNoteTagsRow
	for rows.Next() {
		var i GetNoteTagsRow
		if err := rows.Scan(&i.TagID, &i.UserID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT
  tag_id,
  ordered_id,
  name
FROM notes.tags
WHERE
  user_id = $1
  AND ordered_id >= $2
LIMIT $3
`

type ListTagsParams struct {
	UserID    uuid.UUID
	OrderedID int64
	Limit     int32
}

type ListTagsRow struct {
	TagID     uuid.UUID
	OrderedID int64
	Name      string
}

func (q *Queries) ListTags(ctx context.Context, db DBTX, arg ListTagsParams) ([]ListTagsRow, error) {
	rows, err := db.Query(ctx, listTags, arg.UserID, arg.OrderedID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsRow
	for rows.Next() {
		var i ListTagsRow
		if err := rows.Scan(&i.TagID, &i.OrderedID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveNote = `-- name: SaveNote :one

INSERT INTO notes.notes (
  note_id,
  created_at,
  created_by,
  updated_at,
  updated_by,
  title,
  body
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
) ON CONFLICT (note_id) DO UPDATE
  SET updated_at = excluded.updated_at,
      updated_by = excluded.updated_by,
      title      = excluded.title,
      body       = excluded.body
RETURNING note_id, created_at, created_by, updated_at, updated_by, title, body, search_index
`

type SaveNoteParams struct {
	NoteID    uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy uuid.NullUUID
	UpdatedAt pgtype.Timestamptz
	UpdatedBy uuid.NullUUID
	Title     string
	Body      string
}

// TODO: access control
func (q *Queries) SaveNote(ctx context.Context, db DBTX, arg SaveNoteParams) (NotesNote, error) {
	row := db.QueryRow(ctx, saveNote,
		arg.NoteID,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Title,
		arg.Body,
	)
	var i NotesNote
	err := row.Scan(
		&i.NoteID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Title,
		&i.Body,
		&i.SearchIndex,
	)
	return i, err
}

const searchNotes = `-- name: SearchNotes :many
SELECT
  note_id,
  ts_rank_cd(search_index, $1::text)::float4 AS rank
  -- TODO: highlights: https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-HEADLINE
FROM notes.notes
WHERE
  rank < $2::float4
  AND search_index @@ to_tsquery($1)
ORDER BY
  rank DESC
`

type SearchNotesParams struct {
	Search string
	Rank   float32
}

type SearchNotesRow struct {
	NoteID uuid.UUID
	Rank   float32
}

func (q *Queries) SearchNotes(ctx context.Context, db DBTX, arg SearchNotesParams) ([]SearchNotesRow, error) {
	rows, err := db.Query(ctx, searchNotes, arg.Search, arg.Rank)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchNotesRow
	for rows.Next() {
		var i SearchNotesRow
		if err := rows.Scan(&i.NoteID, &i.Rank); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
