// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const addNoteAccess = `-- name: AddNoteAccess :batchexec
INSERT INTO notes.user_note_access (
  note_id,
  user_id,
  access
) VALUES (
  $1, $2, $3
) ON CONFLICT DO UPDATE
  SET access = excluded.access
`

type AddNoteAccessBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AddNoteAccessParams struct {
	NoteID uuid.UUID
	UserID uuid.UUID
	Access NotesAccessLevel
}

func (q *Queries) AddNoteAccess(ctx context.Context, db DBTX, arg []AddNoteAccessParams) *AddNoteAccessBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.NoteID,
			a.UserID,
			a.Access,
		}
		batch.Queue(addNoteAccess, vals...)
	}
	br := db.SendBatch(ctx, batch)
	return &AddNoteAccessBatchResults{br, len(arg), false}
}

func (b *AddNoteAccessBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *AddNoteAccessBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const addNoteTags = `-- name: AddNoteTags :batchexec
INSERT INTO notes.note_tags (
  note_id, tag_id
) VALUES (
  $1, $2
) ON CONFLICT DO NOTHING
`

type AddNoteTagsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AddNoteTagsParams struct {
	NoteID uuid.UUID
	TagID  uuid.UUID
}

func (q *Queries) AddNoteTags(ctx context.Context, db DBTX, arg []AddNoteTagsParams) *AddNoteTagsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.NoteID,
			a.TagID,
		}
		batch.Queue(addNoteTags, vals...)
	}
	br := db.SendBatch(ctx, batch)
	return &AddNoteTagsBatchResults{br, len(arg), false}
}

func (b *AddNoteTagsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *AddNoteTagsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const deleteNoteAccess = `-- name: DeleteNoteAccess :batchexec
DELETE FROM notes.user_note_access
WHERE
  note_id = $1
  AND user_id = $2
`

type DeleteNoteAccessBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type DeleteNoteAccessParams struct {
	NoteID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteNoteAccess(ctx context.Context, db DBTX, arg []DeleteNoteAccessParams) *DeleteNoteAccessBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.NoteID,
			a.UserID,
		}
		batch.Queue(deleteNoteAccess, vals...)
	}
	br := db.SendBatch(ctx, batch)
	return &DeleteNoteAccessBatchResults{br, len(arg), false}
}

func (b *DeleteNoteAccessBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *DeleteNoteAccessBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const deleteNoteTags = `-- name: DeleteNoteTags :batchexec
DELETE FROM notes.note_tags
WHERE 
  note_id = $1
  AND tag_id = $2
`

type DeleteNoteTagsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type DeleteNoteTagsParams struct {
	NoteID uuid.UUID
	TagID  uuid.UUID
}

func (q *Queries) DeleteNoteTags(ctx context.Context, db DBTX, arg []DeleteNoteTagsParams) *DeleteNoteTagsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.NoteID,
			a.TagID,
		}
		batch.Queue(deleteNoteTags, vals...)
	}
	br := db.SendBatch(ctx, batch)
	return &DeleteNoteTagsBatchResults{br, len(arg), false}
}

func (b *DeleteNoteTagsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *DeleteNoteTagsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
